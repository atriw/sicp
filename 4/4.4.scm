(define (new-and-or-syntax syntax)
  (define (tagged-list? exp tag)
    (if (pair? exp)
      (eq? (car exp) tag)
      #f))
  (define (and? exp) (tagged-list? exp 'and))
  (define (or? exp) (tagged-list? exp 'or))
  (define (dispatch m)
    (cond ((eq? m 'and?) and?)
          ((eq? m 'or?) or?)
          (else (syntax m))))
  dispatch)

(define (make-and-or-implementation evaluator syntax env-model)
  (define no-operands? (syntax 'no-operands?))
  (define first-operand (syntax 'first-operand))
  (define rest-operands (syntax 'rest-operands))
  (define eval (evaluator 'eval))
  (define true? (env-model 'true?))
  (define false? (env-model 'false?))

  (define (eval-and exps env)
    (define true (eval 'true env))
    (define false (eval 'false env))
    (if (no-operands? exps)
      true
      (let ((first (first-operand exps))
            (rest (rest-operands exps)))
        (let ((v (eval first env)))
          (cond ((false? v) false)
                ((no-operands? rest) v)
                (else (eval-and rest env)))))))
  (define (eval-or exps env)
    (if (no-operands? exps)
      (eval 'false env)
      (let ((first (first-operand exps))
            (rest (rest-operands exps)))
        (let ((v (eval first env)))
          (if (true? v)
            v
            (eval-or rest env))))))
  (cons eval-and eval-or))

(define (new-derived-and-or-syntax syntax)
  (define (tagged-list? exp tag)
    (if (pair? exp)
      (eq? (car exp) tag)
      #f))
  (define (and? exp) (tagged-list? exp 'and))
  (define (or? exp) (tagged-list? exp 'or))
  ; Added by Exercise 4.24
  (define (not? exp) (tagged-list? exp 'not))
  (define make-if (syntax 'make-if))
  (define (and->if exps)
    (define (expand exps)
      (if (null? exps)
        'true
        (let ((first (car exps))
              (rest (cdr exps)))
          (if (null? rest)
            (make-if first first 'false)
            (make-if first (expand rest) 'false)))))
    (expand exps))
  (define (or->if exps)
    (define (expand exps)
      (if (null? exps)
        'false
        (let ((first (car exps))
              (rest (cdr exps)))
          (make-if first first (expand rest)))))
    (expand exps))
  (define (not->if exp)
    (make-if (cadr exp) 'false 'true))
  (define (dispatch m)
    (cond ((eq? m 'and?) and?)
          ((eq? m 'or?) or?)
          ((eq? m 'and->if) and->if)
          ((eq? m 'or->if) or->if)
          ((eq? m 'not?) not?)
          ((eq? m 'not->if) not->if)
          (else (syntax m))))
  dispatch)

(define (make-derived-and-or-implementation evaluator syntax env-model)
  (define eval (evaluator 'eval))
  (define and->if (syntax 'and->if))
  (define or->if (syntax 'or->if))

  (define (eval-and exps env)
    (eval (and->if exps) env))
  (define (eval-or exps env)
    (eval (or->if exps) env))
  (cons eval-and eval-or))
