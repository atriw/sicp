(define (make-integral-evaluator syntax environment-model)
  ; exp ::= self-evaluating
  ;         | variable
  ;         | quote
  ;         | assignment
  ;         | definition
  ;         | if
  ;         | lambda
  ;         | begin
  ;         | cond
  ;         | application
  (define self-evaluating? (syntax 'self-evaluating?))
  (define variable? (syntax 'variable?))
  (define quoted? (syntax 'quote?)) ; should be 'quoted?
  (define text-of-quotation (syntax 'text-of-quotation))
  (define assignment? (syntax 'assignment?))
  (define definition? (syntax 'definition?))
  (define if? (syntax 'if?))
  (define lambda? (syntax 'lambda?))
  (define lambda-parameters (syntax 'lambda-parameters))
  (define lambda-body (syntax 'lambda-body))
  (define begin? (syntax 'begin?))
  (define begin-actions (syntax 'begin-actions))
  (define cond? (syntax 'cond?))
  (define cond->if (syntax 'cond->if))
  (define application? (syntax 'application?))
  (define operator (syntax 'operator))
  (define operands (syntax 'operands))
  (define no-operands? (syntax 'no-operands?))
  (define first-operand (syntax 'first-operand))
  (define rest-operands (syntax 'rest-operands))
  (define if-predicate (syntax 'if-predicate))
  (define if-consequent (syntax 'if-consequent))
  (define if-alternative (syntax 'if-alternative))
  (define last-exp? (syntax 'last-exp?))
  (define first-exp (syntax 'first-exp))
  (define rest-exps (syntax 'rest-exps))
  (define assignment-variable (syntax 'assignment-variable))
  (define assignment-value (syntax 'assignment-value))
  (define definition-variable (syntax 'definition-variable))
  (define definition-value (syntax 'definition-value))

  ; Added by Exercise 4.22
  (define let? (syntax 'let?))
  (define let->combination (syntax 'let->combination))

  (define true? (environment-model 'true?))
  (define make-procedure (environment-model 'make-procedure))
  (define compound-procedure? (environment-model 'compound-procedure?))
  (define procedure-parameters (environment-model 'procedure-parameters))
  (define procedure-body (environment-model 'procedure-body))
  (define procedure-environment (environment-model 'procedure-environment))
  (define primitive-procedure? (environment-model 'primitive-procedure?))
  (define apply-primitive-procedure (environment-model 'apply-primitive-procedure))
  (define extend-environment (environment-model 'extend-environment))
  (define lookup-variable-value (environment-model 'lookup-variable-value))
  (define set-variable-value! (environment-model 'set-variable-value!))
  (define define-variable! (environment-model 'define-variable!))

  (define (eval exp env) ((analyze exp) env))

  (define (analyze exp)
    (cond ((self-evaluating? exp) (analyze-self-evaluating exp))
          ((variable? exp) (analyze-variable exp))
          ((quoted? exp) (analyze-quoted exp))
          ((assignment? exp) (analyze-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((if? exp) (analyze-if exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((let? exp) (analyze (let->combination exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ((application? exp) (analyze-application exp))
          (else
            (error "Unknown expression type: ANALYZE" exp))))
  (define (analyze-self-evaluating exp)
    (lambda (env) exp))
  (define (analyze-quoted exp)
    (let ((qval (text-of-quotation exp)))
      (lambda (env) qval)))
  (define (analyze-variable exp)
    (lambda (env) (lookup-variable-value exp env)))
  (define (analyze-assignment exp)
    (let ((var (assignment-variable exp))
          (vproc (analyze (assignment-value exp))))
      (lambda (env)
        (set-variable-value! var (vproc env) env)
        'ok)))
  (define (analyze-definition exp)
    (let ((var (definition-variable exp))
          (vproc (analyze (definition-value exp))))
      (lambda (env)
        (define-variable! var (vproc env) env)
        'ok)))
  (define (analyze-if exp)
    (let ((pproc (analyze (if-predicate exp)))
          (cproc (analyze (if-consequent exp)))
          (aproc (analyze (if-alternative exp))))
      (lambda (env) (if (true? (pproc env))
                      (cproc env)
                      (aproc env)))))
  (define (analyze-lambda exp)
    (let ((vars (lambda-parameters exp))
          (bproc (analyze-sequence (lambda-body exp))))
      (lambda (env) (make-procedure vars bproc env))))
  (define (analyze-sequence exp)
    (define (sequentially proc1 proc2)
      (lambda (env) (proc1 env) (proc2 env)))
    (define (loop first-proc rest-procs)
      (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
    (let ((procs (map analyze exps)))
      (if (null? procs) (error "Empty sequence: ANALYZE"))
      ; (fold-left sequentially (car procs) (cdr procs))))
      (loop (car procs) (cdr procs))))
  (define (analyze-application exp)
    (let ((fproc (analyze (operator exp)))
          (aprocs (map analyze (operands exp))))
      (lambda (env)
        (execute-application
          (fproc env)
          (map (lambda (aproc) (aproc env))
               aprocs)))))
  (define (execute-application proc args)
    (cond ((primitive-procedure? proc)
           (apply-primitive-procedure proc args))
          ((compound-procedure? proc)
           ((procedure-body proc)
            (extend-environment
              (procedure-parameters proc)
              args
              (procedure-environment proc))))
          (else
            (error "Unknown procedure type: EXECUTE-APPLICATION"
                   proc))))

  (define (dispatch m)
    (cond ((eq? m 'eval) eval)
          (else
            (error "Unknown operation" m))))
  dispatch)
